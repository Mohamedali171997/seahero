// File: lib/main.dart
// -----------------------------------------------------------------------------
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_fonts/google_fonts.dart';

import 'screens/menu_screen.dart';
import 'services/audio_service.dart';
import 'services/preferences_service.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Set orientation only on mobile platforms (not web)
  if (!kIsWeb) {
    await SystemChrome.setPreferredOrientations([
      DeviceOrientation.landscapeLeft,
      DeviceOrientation.landscapeRight,
    ]);
  }

  final preferences = PreferencesService();
  await preferences.init();
  final audioService = AudioService(preferencesService: preferences);
  await audioService.preload();

  runApp(SeaHeroApp(
    preferencesService: preferences,
    audioService: audioService,
  ));
}

class SeaHeroApp extends StatelessWidget {
  const SeaHeroApp({
    super.key,
    required this.preferencesService,
    required this.audioService,
  });

  final PreferencesService preferencesService;
  final AudioService audioService;

  @override
  Widget build(BuildContext context) {
    final baseTheme = ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF00B4D8),
        brightness: Brightness.dark,
      ),
      useMaterial3: true,
      textTheme: GoogleFonts.tajawalTextTheme(),
    );

    return MaterialApp(
      title: 'Turtle Hero',
      debugShowCheckedModeBanner: false,
      theme: baseTheme,
      home: MenuScreen(
        preferencesService: preferencesService,
        audioService: audioService,
      ),
    );
  }
}

// -----------------------------------------------------------------------------
// File: lib/game/turtle_hero_game.dart
// -----------------------------------------------------------------------------
import 'dart:async';
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flame/input.dart';
import 'package:flame/events.dart';
import 'package:flutter/foundation.dart';

import '../services/audio_service.dart';
import '../services/preferences_service.dart';
import 'components/background_parallax.dart';
import 'components/jellyfish_component.dart';
import 'components/trash_component.dart';
import 'components/turtle_component.dart';
import 'managers/spawn_manager.dart';
import 'overlays/game_over_overlay.dart';
import 'overlays/hud_overlay.dart';
import 'overlays/pause_overlay.dart';

class TurtleHeroGame extends FlameGame
    with HasCollisionDetection, PanDetector, TapDetector {
  TurtleHeroGame({
    required this.preferencesService,
    required this.audioService,
  });

  final PreferencesService preferencesService;
  final AudioService audioService;

  late TurtleComponent turtle;
  late SpawnManager spawnManager;

  int score = 0;
  int lives = 3;
  int bestScore = 0;
  bool _isManuallyPaused = false;
  bool _isGameOver = false;

  final ValueNotifier<String> factNotifier = ValueNotifier<String>('');
  final ValueNotifier<int> scoreNotifier = ValueNotifier<int>(0);
  final ValueNotifier<int> livesNotifier = ValueNotifier<int>(3);
  final List<String> _facts = [
    'السلاحف البحرية تخلط بين الأكياس البلاستيكية وقناديل البحر.',
    'التلوث الضوئي يربك صغار السلاحف عند خروجها من الأعشاش.',
    'شبكات الصيد المهجورة تحبس آلاف السلاحف كل عام.',
    'إعادة التدوير تساعد في حماية المحيطات من النفايات.',
    'كل قطعة بلاستيك تلتقطها من الشاطئ قد تنقذ حياة كائن بحري.',
  ];
  Timer? _factTimer;

  @override
  Future<void> onLoad() async {
    await super.onLoad();

    await addAll([
      BackgroundParallax(),
      turtle = TurtleComponent(),
      spawnManager = SpawnManager(),
    ]);

    bestScore = preferencesService.bestScore;
    factNotifier.value = _facts.first;
    _factTimer = Timer(6, onTick: _rotateFacts, repeat: true)..start();

    overlays.add(HudOverlay.id);
    audioService.playBgm();
  }

  void _rotateFacts() {
    final next = Random().nextInt(_facts.length);
    factNotifier.value = _facts[next];
  }

  @override
  void update(double dt) {
    super.update(dt);
    _factTimer?.update(dt);
  }

  void handleCollect(JellyfishComponent jellyfish) {
    jellyfish.removeFromParent();
    score += 10;
    scoreNotifier.value = score;
    audioService.playSfx(SfxType.collect);
    if (score > bestScore) {
      bestScore = score;
      unawaited(preferencesService.saveBestScore(score));
    }
  }

  void handleTrashHit(TrashComponent trash) {
    trash.removeFromParent();
    if (_isGameOver) return;
    lives -= 1;
    livesNotifier.value = lives;
    audioService.playSfx(SfxType.hit);
    if (lives <= 0) {
      _triggerGameOver();
    }
  }

  void _triggerGameOver() {
    if (_isGameOver) return;
    _isGameOver = true;
    pauseEngine();
    audioService.pauseBgm();
    bestScore = score > bestScore ? score : bestScore;
    unawaited(preferencesService.saveBestScore(score));
    overlays.remove(HudOverlay.id);
    overlays.add(GameOverOverlay.id);
  }

  void restart() {
    overlays.remove(GameOverOverlay.id);
    overlays.add(HudOverlay.id);
    resumeEngine();
    _isGameOver = false;
    _isManuallyPaused = false;
    score = 0;
    scoreNotifier.value = 0;
    lives = 3;
    livesNotifier.value = 3;
    bestScore = preferencesService.bestScore;
    final trash = children.whereType<TrashComponent>().toList();
    for (final t in trash) {
      t.removeFromParent();
    }
    final jellyfish = children.whereType<JellyfishComponent>().toList();
    for (final j in jellyfish) {
      j.removeFromParent();
    }
    spawnManager.reset();
    turtle.position = Vector2(200, size.y / 2);
    audioService.resumeBgm();
  }

  void togglePause() {
    if (_isGameOver) return;
    if (_isManuallyPaused) {
      resumeGame();
    } else {
      pauseGame();
    }
  }

  void pauseGame() {
    if (_isManuallyPaused) return;
    _isManuallyPaused = true;
    pauseEngine();
    overlays.add(PauseOverlay.id);
    audioService.pauseBgm();
  }

  void resumeGame() {
    if (!_isManuallyPaused) return;
    _isManuallyPaused = false;
    overlays.remove(PauseOverlay.id);
    resumeEngine();
    audioService.resumeBgm();
  }


  @override
  void onPanStart(DragStartInfo info) {
    if (!_isManuallyPaused && !_isGameOver) {
      final y = info.raw.localPosition.dy;
      turtle.moveTo(y);
    }
    // no return value; handler is void
  }

  @override
  void onPanUpdate(DragUpdateInfo info) {
    if (!_isManuallyPaused && !_isGameOver) {
      final y = info.raw.localPosition.dy;
      turtle.moveTo(y);
    }
    // no return value; handler is void
  }

  @override
  void onTapDown(TapDownInfo info) {
    if (!_isManuallyPaused && !_isGameOver) {
      final y = info.raw.localPosition.dy;
      turtle.moveTo(y);
    }
    // no-op return; Flame's mixins expect void for these callbacks
  }

  @override
  void onRemove() {
    factNotifier.dispose();
    scoreNotifier.dispose();
    livesNotifier.dispose();
    _factTimer?.stop();
    super.onRemove();
  }
}

// -----------------------------------------------------------------------------
// File: lib/game/components/background_parallax.dart
// -----------------------------------------------------------------------------

import 'package:flame/components.dart';
import 'package:flame/parallax.dart';

class BackgroundParallax extends ParallaxComponent {
  BackgroundParallax()
      : super(
          priority: -1,
        );

 @override
Future<void> onLoad() async {
      parallax = await game.loadParallax(
      [
        ParallaxImageData('backgrounds/layer1.png'),
        ParallaxImageData('backgrounds/layer2.png'),
        ParallaxImageData('backgrounds/layer3.png'),
      ],
      baseVelocity: Vector2(-20, 0), // Scroll LEFT to simulate forward movement
      velocityMultiplierDelta: Vector2(1.5, 0),
      fill: LayerFill.height,
    );
}
}
// -----------------------------------------------------------------------------
// File: lib/game/components/jellyfish_component.dart
// -----------------------------------------------------------------------------
import 'dart:math';

import 'package:flame/collisions.dart';
import 'package:flame/components.dart';

import '../turtle_hero_game.dart';
import 'turtle_component.dart';

class JellyfishComponent extends SpriteComponent
    with HasGameRef<TurtleHeroGame>, CollisionCallbacks {
  JellyfishComponent()
      : _horizontalDrift = Random().nextDouble() * 40 - 20,
        _rotationTarget = Random().nextDouble() * 0.2;

  final double _horizontalDrift;
  final double _rotationTarget;

  @override
Future<void> onLoad() async {
  await super.onLoad();
  size = Vector2(90, 100);
  anchor = Anchor.center;
  
  // FIX: Remove 'assets/' prefix - Flame adds it automatically
  sprite = await gameRef.loadSprite('entities/jellyfish.png');

  add(CircleHitbox()
    ..collisionType = CollisionType.passive
    ..radius = size.x * 0.35);
}

  @override
  void update(double dt) {
    super.update(dt);
    position += Vector2(_horizontalDrift * dt, 70 * dt);
    angle = sin(position.y / 50) * _rotationTarget;
    if (position.y > gameRef.size.y + size.y) {
      removeFromParent();
    }
  }

  @override
  void onCollisionStart(
    Set<Vector2> intersectionPoints,
    PositionComponent other,
  ) {
    if (other is TurtleComponent) {
      gameRef.handleCollect(this);
    }
    super.onCollisionStart(intersectionPoints, other);
  }
}

// -----------------------------------------------------------------------------
// File: lib/game/components/trash_component.dart
// -----------------------------------------------------------------------------
import 'dart:math';

import 'package:flame/collisions.dart';
import 'package:flame/components.dart';

import '../turtle_hero_game.dart';
import 'turtle_component.dart';

class TrashComponent extends SpriteComponent
    with HasGameRef<TurtleHeroGame>, CollisionCallbacks {
  TrashComponent({
    required this.speed,
  });

  final double speed;
  late final double _rotationSpeed;
  late final double _horizontalDrift; // Slight left/right drift

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    size = Vector2(90, 90);
    anchor = Anchor.center;
    
    final options = [
      'entities/trash_bottle.png',
      'entities/trash_bag.png',
      'entities/trash_straw.png',
      'entities/trash_can.png',
    ];
    final path = options[Random().nextInt(options.length)];

    sprite = await gameRef.loadSprite(path);

    _rotationSpeed = (Random().nextDouble() - 0.5) * 1.2;
    _horizontalDrift = (Random().nextDouble() - 0.5) * 30; // Random drift

    add(CircleHitbox()
      ..collisionType = CollisionType.passive
      ..radius = size.x * 0.35);
  }

  @override
  void update(double dt) {
    super.update(dt);
    // Fall DOWN with slight horizontal drift
    position += Vector2(_horizontalDrift * dt, speed * dt);
    angle += _rotationSpeed * dt;

    // Remove when off BOTTOM of screen
    if (position.y > gameRef.size.y + size.y) {
      removeFromParent();
    }
  }

  @override
  void onCollisionStart(
    Set<Vector2> intersectionPoints,
    PositionComponent other,
  ) {
    if (other is TurtleComponent) {
      gameRef.handleTrashHit(this);
    }
    super.onCollisionStart(intersectionPoints, other);
  }
}

// -----------------------------------------------------------------------------
// File: lib/game/components/turtle_component.dart
// -----------------------------------------------------------------------------
import 'dart:ui';

import 'package:flame/collisions.dart';
import 'package:flame/components.dart';

import '../turtle_hero_game.dart';

class TurtleComponent extends SpriteComponent
    with HasGameRef<TurtleHeroGame>, CollisionCallbacks {
  TurtleComponent();

  double _targetY = 0;
  final double _horizontalSpeed = 150.0; // Constant speed moving right

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    size = Vector2(140, 110);
    anchor = Anchor.center;
    position = Vector2(200, gameRef.size.y / 2);
    _targetY = position.y;

    sprite = await gameRef.loadSprite('entities/turtle.png');

    add(CircleHitbox()
      ..collisionType = CollisionType.active
      ..radius = size.y * 0.35);
  }

  void moveTo(double y) {
    // Clamp Y position to keep turtle on screen
    _targetY = y.clamp(size.y / 2, gameRef.size.y - size.y / 2);
  }

  @override
  void update(double dt) {
    super.update(dt);
    
    // Smooth UP/DOWN movement towards target Y
    final dy = _targetY - position.y;
    position.y += dy * dt * 5;
    
    // Automatic LEFT to RIGHT movement
    position.x += _horizontalSpeed * dt;
    
    // Wrap around when turtle goes off right edge
    if (position.x > gameRef.size.x + size.x) {
      position.x = -size.x;
    }
  }
}

// -----------------------------------------------------------------------------
// File: lib/game/managers/spawn_manager.dart
// -----------------------------------------------------------------------------
import 'dart:math';
import 'package:flame/components.dart';
import '../turtle_hero_game.dart';
import '../components/jellyfish_component.dart';
import '../components/trash_component.dart';

class SpawnManager extends Component with HasGameRef<TurtleHeroGame> {
  SpawnManager();

  double _spawnInterval = 1.8;
  double _timeSinceLastSpawn = 0;
  double _timeSinceLastDifficultyIncrease = 0;
  final double _difficultyIncreaseInterval = 8.0;
  final double _minSpawnInterval = 0.7;
  final Random _random = Random();

  @override
  void update(double dt) {
    super.update(dt);
    
    _timeSinceLastSpawn += dt;
    _timeSinceLastDifficultyIncrease += dt;

    // Increase difficulty over time
    if (_timeSinceLastDifficultyIncrease >= _difficultyIncreaseInterval) {
      _timeSinceLastDifficultyIncrease = 0;
      _spawnInterval = (_spawnInterval - 0.1).clamp(_minSpawnInterval, double.infinity);
    }

    // Spawn objects
    if (_timeSinceLastSpawn >= _spawnInterval) {
      _timeSinceLastSpawn = 0;
      _spawnObject();
    }
  }

  void _spawnObject() {
    // Spawn from TOP of screen at random X position
    final x = _random.nextDouble() * gameRef.size.x;
    final y = -50.0; // Just above the screen
    
    // 30% chance to spawn jellyfish, 70% chance to spawn trash
    if (_random.nextDouble() < 0.3) {
      _spawnJellyfish(x, y);
    } else {
      _spawnTrash(x, y);
    }
  }

  void _spawnJellyfish(double x, double y) {
    final jellyfish = JellyfishComponent()
      ..position = Vector2(x, y);
    gameRef.add(jellyfish);
  }

  void _spawnTrash(double x, double y) {
    final speed = 150.0 + (_random.nextDouble() * 100);
    final trash = TrashComponent(speed: speed)
      ..position = Vector2(x, y);
    gameRef.add(trash);
  }

  void reset() {
    _spawnInterval = 1.8;
    _timeSinceLastSpawn = 0;
    _timeSinceLastDifficultyIncrease = 0;
  }
}